# 物理查询优化

##
## 逻辑查询优化与物理查询优化的区别？

##### 1、逻辑查询优化，主要解决什么问题 ?
如何找出 SQL 语句等价的变换形式，使得 SQL 执行更高效

##### 2、物理查询优化，主要解决什么问题 ?
物理查询优化，主要解决的问题：
###### 1、 从可选的单表扫描方式中，挑选什么样的单表扫描方式是最优的？
单表扫描时，什么时候用全表扫描更快？什么时候用索引更快？

###### 2、 两个表做连接时，如何连接是最优的？
内连接、左外连接、右外连接、全外连接？

###### 3、多个表连接，连接顺序有多种组合，哪种连接顺序是最优的？
多表连接的不同顺序，效率也有差别？

###### 4、多个表连接，连接顺序有多种组合，是否要对每种组合都探索？如果不全部探索，怎么找到最优的一种组合？
MySQL对多表连接优化的支持，实际是使用了贪婪 + 穷举算法 + 剪枝优化的综合算法。


##### 逻辑查询优化 与 物理查询优化 的关系 
先逻辑查询优化，再物理查询优化

物理查询优化把逻辑查询执行计划变为物理操作符，供执行器执行。

MySQL 的逻辑查询执行计划阶段，会对一些子句和表达式进行计算，

到执行阶段时，执行器将不会再次计算，直接利用逻辑查询的优化结果调度执行。


## 物理查询优化 - 代价估算模型
代价估算模型是整个物理查询优化的核心：

单表扫描、两表连接、多表扫描算法都要依据代价估算模型来开展。

##### 1、总代价 = I/O 代价 + CPU 代价 
IO代价：将数据从外存读取到内存所需要的时间；

CPU代价：数据从外存加载到内存中之后，CPU对数据进行运算所需要的时间。如：表连接的操作，求和等操作。

##### 2、COST = Pages * a_page_cpu_time + W * T

###### Pages * a_page_cpu_time
 
Pages为计划运行时访问的页面数， a_page_cpu_time 是每个页面读取的时间花费，其乘积反映了 I/O 花费。

###### T 访问的元组数

反映了 CPU 花费（存储层是以页面为单位，数据以页面的形式被读入内存，每个页面上可能有多条元组，访问元组需要解析元组结构，才能把元组上的字段读出，这消耗的是 CPU ）。

如果是索引扫描，则会还会包括索引读取的花费。

###### W 为权重因子
表明 I/O 到 CPU 的相关性，又称选择率（ selectivity ）。

选择率用于表示在关系 R 中 , 满足条件“ A <op> a” 的元组数与 R的所有元组数N 的**比值**。

选择率的范围：0~1，值越小则选择率越低，就越能利用到索引的优势。


## 物理查询优化 - 单表扫描
单表扫描，主要是指获取表的数据，将数据从外存读取到内存中。

单表扫描是完成两表连接或多表连接的基础/前提。

单表扫描涉及到的是IO操作，而IO操作又是数据库先天的性能瓶颈，所以单表扫描在查询优化中显得非常重要，这也是为什么要使用索引扫描的一个原因。

索引扫描可减少读数据的次数，减少扫描的元组个数，从而达到减少整个IO，加快数据的读取。

##### 全表扫描 - 获取全部数据 
为获取表的全部元组，读取表对应的全部数据页。

##### 局部扫描 / 范围扫描 - 获取部分数据
为获取表的部分元组，读取指定位置对应的数据页。


##### 单表扫描算法的两大类：顺序扫描、索引扫描（重点）

###### 1、顺序扫描（ SeqScan ）
从物理存储上按照存储顺序直接读取表的数据；
当无索引可用，或访问表中的大部分数据，或表的数据量很小，使用顺序扫描效果较好。

###### 2、索引扫描（ IndexScan ）/ 非连续扫描 / 随机扫描
根据索引键读索引，找出物理元组的位置；

根据从索引中找到的位置，从存储读取数据页面；

索引扫描可以将元组按排序的顺序返回；

索引扫描受选择率的影响，如果选择率很低，即表示需要查询的数据很少，所以读数据花费的 IO 会显著减少；

如果选择率很高的话，不适宜使用索引扫描。

另外，注意区分：

索引扫描是随机读取的（也就是说索引所关联的数据在磁盘上不是连续存放的），从加载数据的效率上看没有顺序扫描的效率/吞吐量高。

但是由于基于索引扫描得到数据量会比较小，所以在选择率低的时候，更适合使用索引扫描读取数据。

###### 3、只读索引扫描（ IndexOnlyScan ）/ 覆盖索引
根据索引键读索引，索引中的数据就已经能够满足条件判断，不再需要读取磁盘上数据页面；

通俗的理解：索引树上已经包含需要的数据（投影的列，或查询条件），无需根据索引再去磁盘上定位元组的数据文件。

比索引扫描少了读取数据的 I/O 花费。

##### 单表扫描算法：
不同的单表扫描方式，有着不同的代价。

扫描方式不同，读取的数据量不同，所以IO不同，意味着需要花费的时间是不同的。

##### 实践应用原则：
尽量少获取元组。

---应该尽量避免全表扫描，全表扫描违背了尽量少获取元组的原则！

---------------------------

## 物理查询优化 - 两表连接算法

###### 1、嵌套循环连接算法


###### 2、归并连接算法


###### 3、Hash 连接算法


## 物理查询优化 - 多表连接

##### 1、多表连接的顺序
表的不同的连接顺序，会产生许多不同的连接路径；

不同的连接路径有着不同的效率。

##### 2、多表连接的搜索空间
因为多表连接的顺序不同，产生的连接组合会有多种，如果这个组合的数目巨大。

所有的连接可能构成一个巨大的“搜索空间”。

如何减小搜索空间，在一个可接受的时间范围内，高效地生成查询执行计划将成为一个难点。

如下图所示，同一个查询语义，可以有多棵不同的查询执行树进行表达：

注：树的解析先从叶子节点开始，再向上逐层依次连接。
![mysql-query-tree](https://github.com/clonegod/tools/blob/master/images/mysql-query-tree.png)

---------------------------

## 物理查询优化技术在MySQL上的支持情况

##### 1、MySQL 的代价估算模型
总代价 = I/O 代价 + CPU 代价

COST = Pages * a_page_cpu_time + W * T

总代价 = I/O 代价 + CPU 代价 + Memory 代价 + Remote 代价

##### 2、MySQL 的单表扫描
```
create table tt1(id int primary key, a1 INT, c1 INT, key ka1(a1));
create table tt2(id int primary key, a2 INT, c2 INT, key ka2(a2));
insert into tt1 values(1,1,1),(2,2,2),(3,3,3),(4,4,4);
insert into tt2 values(1,1,2),(2,2,2);
```


》》 示例1：全表扫描

```
EXPLAIN
-- c1 列没有索引，使用了全表扫描
-- 优化建议：如果c1列的选择率低于10%，则可以在c1列上加索引
SELECT c1 FROM tt1 WHERE c1>0;
```

---
| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | 
| -: | - | - | - | - | - | - | - | -: | - | 
| 1 | SIMPLE | tt1 | ALL | NULL | NULL | NULL | NULL | 4 | Using where | 


》》 示例2：索引扫描

```
EXPLAIN
-- id列有为主键，有索引，基于索引进行范围查找
SELECT c1 FROM tt1 WHERE id>0;
```

---
| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | 
| -: | - | - | - | - | - | - | - | -: | - | 
| 1 | SIMPLE | tt1 | range | PRIMARY | PRIMARY | 4 | NULL | 4 | Using where | 


》》 示例3：只读索引扫描

```
EXPLAIN
-- id在索引中已经存在，因此进行只读索引扫描，无需根据索引再去读取文件
SELECT id FROM tt1 WHERE id>0;
```

---
| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | 
| -: | - | - | - | - | - | - | - | -: | - | 
| 1 | SIMPLE | tt1 | index | PRIMARY | ka1 | 5 | NULL | 4 | Using where; Using index | 



##### 3、MySQL 的两表连接

》》  示例1：BNL，块嵌套循环连接算法

```
EXPLAIN
SELECT * FROM tt1,tt2;
```

| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | 
| -: | - | - | - | - | - | - | - | -: | - | 
| 1 | SIMPLE | tt2 | ALL | NULL | NULL | NULL | NULL | 2 | NULL | 
| 1 | SIMPLE | tt1 | ALL | NULL | NULL | NULL | NULL | 4 | Using join buffer (Block Nested Loop) | 


》》 示例2：BNL，块嵌套循环连接算法

```
EXPLAIN
SELECT * FROM tt1,tt2 WHERE c1=c2;
```

| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | 
| -: | - | - | - | - | - | - | - | -: | - | 
| 1 | SIMPLE | tt2 | ALL | NULL | NULL | NULL | NULL | 2 | NULL | 
| 1 | SIMPLE | tt1 | ALL | NULL | NULL | NULL | NULL | 4 | Using where; Using join buffer (Block Nested Loop) | 


##### 4、MySQL 的多表连接

###### 贪婪 - 穷举算法
贪婪算法，体现在基于有序的表进行连接时，每一次依照次序进行连接的表，贪婪算法都认为这种连接方式是最优的。

所以在每一次连接的过程中，主要完成的任务，就是求解本次要连接的表对象的最佳访问方式。

可调优的参数：

	1 optimizer_prune_level=1 ，剪枝参数
		去掉搜索空间的一部分内容，跳过一些连接次序，提高速度。
		MySQL对多表连接优化的支持，实际是使用了贪婪 + 穷举算法 + 剪枝优化的综合算法。
		
	2 optimizer_search_depth ，控制搜索空间的深度
		如果连接的表很多，则设置最小值为表的个数，
		MySQL会搜索所有可能的连接顺序，从中找出最优的执行计划，不过优化器的执行效率会比较低。
		为了能够尽快得到查询执行计划，则可调小该参数值，但得到的查询执行计划可能不是最优的。
